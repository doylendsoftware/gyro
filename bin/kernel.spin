'THIS FILE IS AUTOMATICALLY GENERATED BY THE PREPROCESSOR.
'DO NOT OVERWRITE.

con

    _clkmode = xtal1 + pll16x
    _xinfreq = 5_000_000
    
    FREQUENCY = 80_000_000
    
    SERIAL_BAUD = 19_200
    SERIAL_BIT_TICKS = FREQUENCY / SERIAL_BAUD
    SERIAL_TX = 0
    SERIAL_RX = 31

	BLOCKS = 32


pub main
    'serdrv := @ser_entry
    lockset(1)
    coginit(1,@ser_entry,128)
    'waitcnt(cnt+clkfreq*5)
    coginit(0,@kernel,0)

dat

kernel
                    org $000
'Note: Lock 0 is memory, lock 1 is boot hold, lock 2 is SPI

'Code is kept in 256-long blocks. Each block has one long in a
'table to determine whether it can be used. The table is pro-
'tected by Lock 0. 
'
'Each long contains: owner (1 byte), execution masks (1 byte),
'used (1 byte) and one empty byte.
'

begin
                    call #clear_block_table
                    call #sys_alloc '0, of course. Also mailboxes.
                    'Prep serial
                    mov x, #SERIAL_RX
                    wrlong x, #128 'rxpin
                    mov x, #SERIAL_TX
                    wrlong x, #132 'txpin
                    mov x, #0
                    wrlong x, #136 'mode
                    mov x, bitticks_tophalf
                    wrlong x, #140 'bitticks
                    neg x, #1
                    wrlong x, #144 'rxbuff
                    neg x, #1
                    wrlong x, #148 'txbuff
                    'Lets release the lock
                    mov x, #1
                    lockclr x
                    mov k, #"#" 'Send character to indicate boot successful
                    call #sys_char
                    
                    call #sys_getch 'Wait for keypress

editor              'Tiny hex editor
                    'call #cls
ed_loop             
                    mov k, #128 'Cursor home
                    call #send_char
                    mov x, ed_addr
                    mov y, #4
ed_display_loop     mov i, x
                    call #debug_hex
                    mov k, #32
                    call #send_char
                    mov k, #"|"
                    call #send_char
                    mov k, #32
                    call #send_char
                    rdlong i, x
                    call #debug_hex
                    mov k, #32
                    call #send_char
                    
                    add x, #4
                    djnz y, #ed_display_loop
                    
                    call #recv_char
                    cmp j, #"p" wz      'Back
              if_z  sub ed_addr, #4
                    cmp j, #";" wz      'Forward
              if_z  add ed_addr, #4 
                    cmp j, #"]" wz      'Backlight ON
              if_z  mov k, #17
              if_z  call #send_char
                    cmp j, #"[" wz      'Backlight OFF
              if_z  mov k, #18
              if_z  call #send_char
                    
                    cmp j, #"=" wz        'Alloc block
              if_z  call #sys_alloc
              
                    cmp j, #"-" wz      'Dealloc block
              if_z  mov i, ed_addr
              if_z  shr i, #2      
              if_z  call #dealloc      

                    cmp j, #"/" wz
              if_z  jmp #dumb_launch            'Dumb launch

                                        
                    mov x, j
                    sub x, #48 wc
              if_c  jmp #test_digit_done
                    mov y, #9
                    cmp y, x wc
              if_c  jmp #test_digit_done
                    rdlong y, ed_addr
                    shl y, #4
                    add y, x
                    wrlong y, ed_addr
                    
                    
test_digit_done     
                    mov x, j
                    sub x, #97 wc
              if_c  jmp #test_alpha_done
                    mov y, #5
                    cmp y, x wc
              if_c  jmp #test_alpha_done
                    add x, #10
                    rdlong y, ed_addr
                    shl y, #4
                    add y, x
                    wrlong y, ed_addr
test_alpha_done

                    jmp #ed_loop

ed_addr             long 0
bitticks_tophalf    long SERIAL_BIT_TICKS

dumb_launch         
                    mov y, #ed_addr
                    shl y, #4
                    or y, #8
                    coginit y
                    jmp #ed_loop

padding             'long  
                    'long         
                    'long 
                    'long 
                    'long
                    long 0,0,0,1,0,1,0,0,0,0,0
                    long 0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
                    long 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                    long 0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0
                    long 0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0
                    long 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                    long 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                    long 0,1,1,1,0,1,1,0,1,1,0,1,1,0,0,0
                    long 0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0
                    long 0,0,1,0,0,1,0,1,0,1,0,1,1,0,0,0
                    long 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0



sys_halt        jmp #sys_halt
zero            long 0

i               long 0
j               long 0
k               long 0
x               long 0
y               long 0
z               long 0

sys_alloc       call #alloc
sys_alloc_ret   ret
sys_dealloc     call #dealloc
sys_dealloc_ret ret
sys_contig      call #alloc_contig
sys_contig_ret  ret
sys_char        call #send_char
sys_char_ret    ret
sys_hex         call #debug_hex
sys_hex_ret     ret
sys_getch       call #recv_char
sys_getch_ret   ret




clear_block_table   mov i, #32 
                    mov j, #0
clear_loop          wrlong zero, j
                    add j, #4
                    djnz i,#clear_loop
clear_block_table_ret ret

alloc_contig        'Allocate a contiguous set of blocks, i is number of blocks
                    'NOTES: j counts contig
                    'Uses first-avail strategy
                    'Not efficient
contig_lock_loop     lockset zero wc 'Try to set the lock
            if_c    jmp #contig_lock_loop
                    'We have the lock
                    mov k, #0 'Counts address index
                    mov j, #0 'Counts contig sf
finder_loop         rdlong x, k wz 'Get from table to x
            if_z    add j,#1 'Got something? Add
            if_nz   mov j, #0 'Not empty? Reset
                    'Increment k (does not check for overflow TODO)
                    add k, #4

                    'If we have i, success
                    cmp i, j wz 
            if_z    jmp #contig_good
                    jmp #finder_loop
contig_good         'All good!
                    shr k, #2 'Make K the index instead of address.
                    sub k, i  'Find first block
                    mov z, k   'Stow it in Z
                    'Mark (terrible hack, must fix TODO)
                    neg y, #1
                    shl k, #2
contig_alloc_loop   wrlong y,k
                    add k,#4
                    djnz i, #contig_alloc_loop
                    lockclr zero
alloc_contig_ret    ret

alloc               'Allocate a block
alloc_lock_loop     lockset zero wc 'Try to set the lock
            if_c    jmp #alloc_lock_loop
                    'We have the lock
                    'mov k, #"R"
                    'call #send_char
                    mov j, #0
                    mov x, #blocks
alloc_find_loop     
                    rdlong k, j 'Allocated? (TODO)
                    
                    
                    tjz k, #finish_good 'If not allocated, go fix!
                    
                    add j, #4
                    djnz x, #alloc_find_loop
                    'If we got here, no free block
                    'Stow -1 in j
                    neg j, #1
                    'Address is in j
alloc_finish        lockclr zero
                    jmp #alloc_ret
finish_good         neg k, #1
                    wrlong k, j
                    lockclr zero
                    shr j, #2 'Move j to be index not addr
alloc_ret   ret


dealloc             'Deallocate a block. Block is in i.
dealloc_lock_loop     lockset zero wc 'Try to set the lock
            if_c    jmp #dealloc_lock_loop
                    'We have the lock
                    shl i, #2 'Multiply by 4 to get long
                    'We don't even bother checking it right now TODO
                    wrlong zero,i
                    
                    lockclr zero
                    
dealloc_ret         ret




send_char           rdlong j, #148 'USES J
                    shr j, #31 wz
               if_z jmp #send_char
                    wrlong k, #148
                    
send_char_ret       ret

'#144
recv_char           'Uses j and k. Character is in j.  
                    rdlong j, #144
                    neg k, #1
                    xor k, j
                    tjz k, #recv_char
                    neg k, #1
                    wrlong k, #144
                   
recv_char_ret       ret

debug_hex           'Assumes item is in i; uses j, k,and z
                    mov z, #8
debug_hex_loop      
                    mov k,i
                    shr k, #28
                    and k, #$f
                    cmp k, #10 wc
              if_nc add k, #55
              if_c  add k, #48
                    shl i, #4
                    call #send_char
                    djnz z, #debug_hex_loop
                    
debug_hex_ret       ret



spi_long            'Channel in i, data in k, bits in j.
                    'Uses x,y,z. Destroys all.
                    mov x, #2
                    lockset x wc
              if_c  jmp #spi_long
                    'We have the lock. For safety's sake, toggle CLR.
                    mov x, #1
                    shl x, #8
                    or outa, x 'Toggle CLR        'FIXME: Set up dira
                    nop
                    xor outa, x 'Turn it off
                    mov x, #1
                    shl x, #25
                    tjz i, #spi_select_done
spi_select_loop     
                    or outa, x
                    nop
                    xor outa, x
                    djnz i, #spi_select_loop
spi_select_done



                    fit 496


'HACKED SERIAL DRIVER -----------------------------------------

dat
                        org $000


ser_entry               mov     t1,par                'get structure address
                        mov t2,#1
ser_unlock_loop         lockset t2 wc
                  if_c  jmp #ser_unlock_loop
                        mov t2, #1
                        shl t2, #15
                        or dira,t2
                        or outa,t2
                        rdlong  t2,t1                 'get rx_pin
                        mov     rxmask,#1
                        shl     rxmask,t2

                        add     t1,#4                 'get tx_pin
                        rdlong  t2,t1
                        mov     txmask,#1
                        shl     txmask,t2

                        add     t1,#4                 'get rxtx_mode
                        rdlong  rxtxmode,t1

                        add     t1,#4                 'get bit_ticks
                        rdlong  bitticks,t1

                        add     t1,#4                 'get buffer_ptr
                        mov     rxbuff, t1
                        add     t1, #4
                        mov     txbuff, t1

                        test    rxtxmode,#%100  wz    'init tx pin according to mode
                        test    rxtxmode,#%010  wc
        if_z_ne_c       or      outa,txmask
        if_z            or      dira,txmask

                        mov     txcode,#transmit      'initialize ping-pong multitasking



receive                 jmpret  rxcode,txcode         'run chunk of tx code, then return

                        test    rxtxmode,#%001  wz    'wait for start bit on rx pin
                        test    rxmask,ina      wc
        if_z_eq_c       jmp     #receive

                        mov     rxbits,#9             'ready to receive byte
                        mov     rxcnt,bitticks
                        shr     rxcnt,#1
                        add     rxcnt,cnt

:bit                    add     rxcnt,bitticks        'ready next bit period

:wait                   jmpret  rxcode,txcode         'run chunk of tx code, then return

                        mov     t1,rxcnt              'check if bit receive period done
                        sub     t1,cnt
                        cmps    t1,#0           wc
        if_nc           jmp     #:wait

                        test    rxmask,ina      wc    'receive bit on rx pin
                        rcr     rxdata,#1
                        djnz    rxbits,#:bit

                        shr     rxdata,#32-9          'justify and trim received byte
                        and     rxdata,#$FF
                        test    rxtxmode,#%001  wz    'if rx inverted, invert byte
        if_nz           xor     rxdata,#$FF

                        wrlong  rxdata, rxbuff

                        jmp     #receive              'byte done, receive next byte



transmit                jmpret  txcode,rxcode         'run chunk of rx code, then return

        
                        rdlong  t1, txbuff
                        shr t1, #31 wz
        if_nz           jmp #transmit
        
                        rdlong txdata, txbuff
                        neg t2, #1
                        wrlong t2, txbuff
                                        
                        
                        or      txdata,#$100          'ready byte to transmit
                        shl     txdata,#2
                        or      txdata,#1
                        mov     txbits,#11
                        mov     txcnt,cnt

:bit                    test    rxtxmode,#%100  wz    'output bit on tx pin
                        test    rxtxmode,#%010  wc    'according to mode
        if_z_and_c      xor     txdata,#1
                        shr     txdata,#1       wc
        if_z            muxc    outa,txmask
        if_nz           muxnc   dira,txmask
                        add     txcnt,bitticks        'ready next cnt

:wait                   jmpret  txcode,rxcode         'run chunk of rx code, then return

                        mov     t1,txcnt              'check if bit transmit period done
                        sub     t1,cnt
                        cmps    t1,#0           wc
        if_nc           jmp     #:wait

                        djnz    txbits,#:bit          'another bit to transmit?

                        jmp     #transmit             'byte done, transmit next byte



t1                      res     1
t2                      res     1
t3                      res     1

rxtxmode                res     1
bitticks                res     1

rxmask                  res     1
rxbuff                  res     1
rxdata                  res     1
rxbits                  res     1
rxcnt                   res     1
rxcode                  res     1

txmask                  res     1
txbuff                  res     1
txdata                  res     1
txbits                  res     1
txcnt                   res     1
txcode                  res     1

